/*******************************************************************************
 * ISPTAP - Instruction Scratchpad Timing Analysis Program
 * Copyright (C) 2013 Stefan Metzlaff, University of Augsburg, Germany
 * URL: <https://github.com/smetzlaff/isptap>
 * 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program, see <LICENSE>. If not, see
 * <http://www.gnu.org/licenses/>.
 ******************************************************************************/
#include "carcore_dump_parser.hpp"
#include "tricore_isa.hpp"
#include "tricore_dumpline_parser.hpp"

/*
 * CarCoreDumpParser
 * parses dump files generated by tricore-objdump
 * builds the CFG for the input file.
 */

//LoggerPtr CarCoreDumpParser::logger(Logger::getLogger("CarCoreDumpParser"));

CarCoreDumpParser::CarCoreDumpParser(uint32_t core_number) : DumpParser(core_number)
{
	dlp = TriCoreDumpLineParser::getInstance();
	isa = TricoreISA::getInstance();
}

CarCoreDumpParser::~CarCoreDumpParser(void)
{
//	dlp = NULL;
//	isa = NULL;
}

void CarCoreDumpParser::parseLabels(void)
{
	for(uint i = 0; i < label_vec.size(); i++)
	{
		// TODO do not create cfgs for all labels, just for called ones!, then the isIgnoreLabel() function can be deleted

		// there are some labels in the vector that a just normal jump labels, these for these labels a cfg should not be created. the isIgnoreLabel() function is a bad workaround for that!
		if(!dlp->isIgnoreLabel(label_vec[i].label))
		{
			function_graph_t tmp;
			tmp.address = label_vec[i].address;
			tmp.name = label_vec[i].label;
			if(label_vec[i].label.compare(STARTUP_CODE_BEGIN_LABEL)==0)
			{
				LOG_INFO(logger, "Creating cfg for startup label " << tmp.name << " at 0x" << hex << tmp.address);
				tmp.cfg = parseCfgForStartLabel(label_vec[i]);
				func_cfgs.push_back(tmp);
				LOG_DEBUG(logger, "Found labels to blacklist:");
				for(uint32_t j = 0; j < blacklist_label.size(); j++)
				{
					LOG_DEBUG(logger, "Name: " << blacklist_label[j].label << " addr: 0x" << hex << blacklist_label[j].address);
				}
			}
			else
			{
				bool label_not_blacklisted = true;

				for(uint32_t j = 0; j < blacklist_label.size(); j++)
				{
					if(blacklist_label[j].address == label_vec[i].address)
					{
						assert(blacklist_label[j].label.compare(label_vec[i].label)==0);
						label_not_blacklisted = false;
						break;
					}
					else
					{
						// be sure that address and label are the same
						assert(blacklist_label[j].label.compare(label_vec[i].label)!=0);
					}
				}

				if(label_not_blacklisted)
				{
					LOG_INFO(logger, "Creating cfg for label " << tmp.name << " at 0x" << hex << tmp.address);
					tmp.cfg = parseCfgForLabel(label_vec[i]);
					func_cfgs.push_back(tmp);
				}
			}
		}
		else
		{
			LOG_INFO(logger, "Ignoring label: " << label_vec[i].label << " at 0x" << hex << label_vec[i].address << ". No cfg is created for that label.");
		}
	}
}

ControlFlowGraphObject *CarCoreDumpParser::parseCfgForStartLabel(addr_label_t function)
{
	ControlFlowGraphObject *cfgobj = new ControlFlowGraphObject();

	if((analysis_metric_t) conf->getUint(CONF_USE_METRIC) == WCET_RATIO_FILES)
	{
		cfgobj->setRatioFileReaders(rfr_onchip, rfr_offchip);
	}

	bool function_start_found = false;
	uint32_t dump_line = 0;
	for(dump_line=0; (dump_line < unparsed_file_content.size())&&(!function_start_found); dump_line++)
	{	
		const string str = unparsed_file_content[dump_line];
		if(dlp->isLabelLine(str))
		{
			addr_label_t tmp = dlp->getAddrAndLabelFromLabelLine(str);
			if(tmp.address == function.address)
			{
				assert(!function.label.compare(tmp.label));
				function_start_found = true;
			}
		}

	}

	bool in_bb = false;
	string bb_code;
	uint32_t bb_start=0;
	uint32_t bb_size=0;
	uint32_t bb_instrs=0;
	bool finished = false;
	dump_line--;
	uint32_t parsed_dump_lines_begin=dump_line;
	uint32_t parsed_dump_lines_end=dump_line;

	for(/* dump_line: start with value where the label was found */; (dump_line < unparsed_file_content.size())&&(!finished); dump_line++)
	{
		const string str = unparsed_file_content[dump_line];
		parsed_dump_lines_end=dump_line;
//		LOG_DEBUG(logger, str);
		if(dlp->isCodeLine(str))
		{
			LOG_DEBUG(logger, "found instruction: " << str);
			string instruction = dlp->getInstructionFromCodeLine(str);
			uint op_length = isa->getInstructionLength(instruction);
			uint32_t curr_addr = dlp->getAddrFromCodeLine(str);
			bool is_jump_target = false;
			for(uint i = 0; i < jump_target_vec.size(); i++)
			{
				if(jump_target_vec[i] == curr_addr+op_length)
				{
					is_jump_target = true;
					break;
				}
			}

			if(!in_bb)
			{
				// start of a new bb
				in_bb = true;
				bb_start = curr_addr;
			}

			bb_code += str;
			bb_code += "\r"; /// adding carriage return to ease parsing of code for raw file creation
			bb_size += isa->getInstructionLength(dlp->getInstructionFromCodeLine(str));
			bb_instrs++;
			bool is_branch = dlp->isBranchInstr(str);
			if(is_branch || is_jump_target)
			{
				// end of bb
				if(is_branch)
				{
					if(dlp->isCondBranchInstr(str))
					{
						LOG_DEBUG(logger, "bb creation on conditional branch: ");
						jump_target_address_t target = isa->getJumpTargetAddr(instruction, curr_addr);
						if(!target.valid)
						{
							LOG_WARN(logger, "In function " << function.label << " (0x" << hex << function.address << ") cannot obtain jump target addr using addr 0x" << hex << UNKNOWN_ADDR << " instead");
							vector<uint32_t> jump_targets = jte.getJumpTargetsForIndirectJump(bb_start);
							if(jump_targets.size() == 0)
							{
								cfgobj->addBBNode(bb_start, curr_addr, curr_addr+op_length, UNKNOWN_ADDR, bb_code, bb_size, bb_instrs);
							}
							else
							{
								for(uint32_t i=0; i < jump_targets.size(); i++)
								{
									LOG_INFO(logger, "Using JTE: found the target: 0x" << hex << jump_targets[i] << " to which a jump from 0x" << bb_start << " is possible");
								}
								cfgobj->addBBNode(bb_start, curr_addr, curr_addr+op_length, jump_targets, bb_code, bb_size, bb_instrs);
							}
						}
						else
						{
							cfgobj->addBBNode(bb_start, curr_addr, curr_addr+op_length, target.addr, bb_code, bb_size, bb_instrs);
						}
					}
					else if(dlp->isReturnInstr(str))
					{
						LOG_DEBUG(logger, "bb creation on return: ");
						cfgobj->addBBNode(bb_start, curr_addr, bb_code, bb_size, bb_instrs);
					}
					else if(dlp->isCallInstr(str))
					{
						addr_label_t tmp;
						//TODO do not connect call targets as normal edges
						LOG_DEBUG(logger, "bb creation on call: ");
						jump_target_address_t target = isa->getJumpTargetAddr(instruction, curr_addr);
						if(!target.valid)
						{
							tmp.address = UNKNOWN_ADDR;
							tmp.label = "NOLABEL";
							LOG_WARN(logger, "In function " << function.label << " (0x" << hex << function.address << ") cannot obtain jump target addr using addr 0x" << hex << UNKNOWN_ADDR << " instead");
							vector<uint32_t> jump_targets = jte.getJumpTargetsForIndirectJump(bb_start);
							if(jump_targets.size() == 0)
							{
								cfgobj->addBBCallNode(bb_start, curr_addr, curr_addr+op_length, bb_code, bb_size, bb_instrs, tmp);
							}
							else
							{
								// Implementation missing :)
								assert(false);
							}
						}
						else
						{
							tmp = getAddrLabelForAddr(target.addr);
							cfgobj->addBBCallNode(bb_start, curr_addr, curr_addr+op_length, bb_code, bb_size, bb_instrs, tmp);
						}
					}
					else 
					{
						LOG_DEBUG(logger, "bb creation on unconditional branch: ");
						jump_target_address_t target = isa->getJumpTargetAddr(instruction, curr_addr);
						if(!target.valid)
						{
							LOG_WARN(logger, "In function " << function.label << " (0x" << hex << function.address << ") cannot obtain jump target addr using addr 0x" << hex << UNKNOWN_ADDR <<" instead");

							vector<uint32_t> jump_targets = jte.getJumpTargetsForIndirectJump(bb_start);
							if(jump_targets.size() == 0)
							{
								cfgobj->addBBNode(bb_start, curr_addr, UNKNOWN_ADDR, bb_code, bb_size, bb_instrs);
							}
							else
							{
								for(uint32_t i=0; i < jump_targets.size(); i++)
								{
									LOG_INFO(logger, "Using JTE: found the target: 0x" << hex << jump_targets[i] << " to which a jump from 0x" << bb_start << " is possible");
								}
								cfgobj->addBBNode(bb_start, curr_addr, jump_targets, bb_code, bb_size, bb_instrs);
							}

						}
						else
							cfgobj->addBBNode(bb_start, curr_addr, target.addr, bb_code, bb_size, bb_instrs);
					}
					// check if all basic blocks are created for this function 
					finished = cfgobj->isFinished();
				}
				else
				{
					LOG_DEBUG(logger, "bb creation on jump target found: ");
					cfgobj->addBBNode(bb_start, curr_addr, curr_addr+op_length, bb_code, bb_size, bb_instrs);
				}
				bb_code = "";
				bb_size = 0;
				bb_instrs = 0;
				in_bb = false;
			}
			else if(dlp->isDebugInstr(str))
			{
				// on end of statup code a debug instruction is placed, this completes the startup code
				LOG_DEBUG(logger, "bb creation on debug: ");
				bb_code += "Disassembly of section .text:";
				cfgobj->addBBNode(bb_start, curr_addr, bb_code, bb_size, bb_instrs);
				// check if all basic blocks are created for this function 
				finished = cfgobj->isFinished();
			}

		}
		else if(dlp->isLabelLine(str))
		{
			bb_code += str;
			bb_code += "\r"; /// adding carriage return to ease parsing of code for raw file creation

			// blacklist all labels that are found wile parsing the startup cfg from the label list
			addr_label_t label = dlp->getAddrAndLabelFromLabelLine(str);
			if(label.address != function.address)
			{
				blacklist_label.push_back(label);
			}
		}
	}

	// delete parsed lines from unparsed_file_content vector
	unparsed_file_content.erase((unparsed_file_content.begin()+parsed_dump_lines_begin), (unparsed_file_content.begin()+parsed_dump_lines_end+1));

	LOG_DEBUG(logger, "Finished creation of cfg for " << function.label << " at 0x" << hex << function.address);

	return cfgobj;
}
